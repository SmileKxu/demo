<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>ES6 let</title>
</head>
<body>


<script>
	/*
      ES6 新增了let命令，用来声明变量。他的用法类似于var，但是声明的变量只在
      let命令所在的代码块内有效。
	*/ 
	// function fun(){
 //       // let a = 10;
 //       var b = 1;
	// }
	{
		let a = 10;
		var b = 1;
	}
	// console.log(a); // a is not defined.
	console.log(b);

	// let 变量只能在它所在的代码块内有效

	for (let i = 0; i < 5; i++){

		console.log(i);

	}
	//	console.log(i); // i is not defined
	console.log('----------------------------------');
	function ceshi(){
		var a = [];
		for (let i = 0; i < 10; i++) {
			a[i] = function(){
				console.log(i);
			};
		}
		// console.log(a);
		console.log(a[6]());
	}

	ceshi();

	console.log('222222222222222222222222222222');
    
    // 在 for 循环内，设置循环变量的那部分与循环体内的部分是一个单独的子作用域
	for (let i = 0; i < 3; i++){
        let i = 'abc';
        console.log(i);
	}

	// let 不存在变量声明提升，声明的变量一定要在声明后使用，否则报错

	if (true) {

		// tmp = 'abc';
		// console.log(tmp);

		let tmp;
		console.log(tmp);

		tmp = 123;
		console.log(tmp);  
	}

	//暂时性死区 也意味着 typeof 不再是一个百分之百的操作
	/*
       typeof x; //这样检测 x 的数据类型会报错
       let x;   
	*/
	// console.log(typeof x);
	// let x;

	console.log(typeof xxx); // 对于一个未声明的变量 使用typeof 会打印 undefind

	//let 不允许在相同作用域内，重复声明同一个变量。
	function func(arg){
		let arg;  // 报错
		// console.log()
	}
	// func();


	




</script>	
</body>
</html>